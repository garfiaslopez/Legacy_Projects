/* Copyright (c) 2012, 2013  BlackBerry Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "FileStorage.hpp"

#include "Person.hpp"

using namespace bb::cascades;

const QString FileStorage::m_personsFilePath = "./data/PersonList.dat";

FileStorage::FileStorage()
{
}

FileStorage::~FileStorage()
{
}

// Clear the objects in our custom data file.
bool FileStorage::clear()
{
    QFile peopleFile(m_personsFilePath);
    return peopleFile.remove();
}
//! [0]
bool FileStorage::save(int lastID, GroupDataModel *model)
{
    QFile personFile(m_personsFilePath);

    if (!personFile.open(QIODevice::WriteOnly))
        return false;

    QDataStream stream(&personFile); // Open a stream into the file.

    const bool saved = serializeDataModel(lastID, model, &stream); // Put the data model into the stream.

    personFile.close();

    return saved;
}

bool FileStorage::serializeDataModel(int lastID, GroupDataModel* model, QDataStream* stream)
{
    // This is a simple serialization function.
    // For more info on dealing with complex types,
    // or incorporating file versions see "Serializing data type in Qt"
    // http://qt-project.org/doc/qt-4.8/datastreamformat.html
    bool addedData = false;

    *stream << lastID;
    if (stream->status() == QDataStream::Ok) {
        for (int i = 0; i < model->size(); i++) {
            Person *person = (Person *) model->children()[i];
            *stream << person->customerID() << person->firstName()
                    << person->lastName();
            if (stream->status() != QDataStream::Ok) {
                return addedData = false;
            }
        }
        addedData = true;
    }

    return addedData;
}
//! [0]
//! [1]
int FileStorage::load(int& lastID, GroupDataModel *model)
{
    // return the number of persons loaded.
    int loadedCount = 0;

    // open the custom file for writing.
    QFile file(m_personsFilePath);
    if (!file.open(QIODevice::ReadOnly)) {
        return loadedCount;
    }

    // Load from the stream into the dataModel.
    // The function deserializeIntoDataModel() will create the person instances
    // and add them to the given dataModel
    QDataStream stream(&file);
    loadedCount = deserializeIntoDataModel(&stream, model, lastID);
    file.close();

    return loadedCount;
}

int FileStorage::deserializeIntoDataModel(QDataStream *stream, GroupDataModel *model, int& lastID)
{
    // Return number of persons deserialized.
    int loadedCount = 0;

    // Check in case the stream is empty.
    if (stream->atEnd())
        return loadedCount;

    // 1. Get the last customer id from the stream and set the member.
    if (!loadLastCustomerID(stream, lastID))
        return loadedCount;

    // 2. Get the person objects.
    while (!stream->atEnd()) {
        if (loadPerson(stream, model)) {
            loadedCount++;
        } else {
            break; // Stop reading after error.
        }
    }

    return loadedCount;
}

bool FileStorage::loadPerson(QDataStream* stream, GroupDataModel *model)
{
    bool loaded = false;

    // Load the data into temporary variables.
    QString id, firstName, lastName;
    *stream >> id >> firstName >> lastName;

    // Check for errors in the read.
    if (stream->status() == QDataStream::Ok) {
        // Add a new person object to the data model.
        model->insert(new Person(id, firstName, lastName)); // Note the model will delete Person when the time comes.
        loaded = true;
    }

    return loaded;
}
//! [1]
bool FileStorage::loadLastCustomerID(QDataStream* stream, int& id)
{
    bool loaded = false;
    int lastID;

    // Get the last customer id first.
    // ID's will be generated by incrementing this number
    *stream >> lastID;

    // Check for errors in the read.
    if (stream->status() == QDataStream::Ok) {
        loaded = true;
        id = lastID; // return the id
    }

    return loaded;
}
